一：redis作为缓存的实现
1：客户端查询数据时先查询缓存中是否存在
2：存在，则返回缓存中数据
3：不存在，则去数据库中查询
4：数据库查询存在该数据，更新缓存，并返回数据
5：数据库中不存在，返回不存在信息

二：缓存雪崩：

1：概念
多个key在同一时间过期，导致客户端查询数据时不经过缓存从而直接查询数据库

2：解决方案
（1）：在过期时间上设置随机值，防止大量key在同一时间过期
（2）：
（3）规避雪崩：redis搭建高可用集群
（4）出现雪崩：服务降级和熔断

三：缓存穿透

1：概念：客户端多次访问一个不存在的key，查询不经过缓存从而直接访问数据库

2：解决方案
（1）：设置null值：对于数据库中也查不到的数据，我们将key值也缓存到redis中，将null作为value值，但是这样只能解决单个key的缓存穿透问题，而且redis中会缓存大量null，浪费空间
（2）：使用布隆过滤器：在查询缓存之前先经过布隆过滤器进行过滤，若数据不存在，则直接返回数据不存在

3：布隆过滤器

（1）概念：布隆过滤器底层依赖于bit，类似于数组，数组存储着bit位，初始每个bit位都为0，当有值时就设置为1
（2）put方法：通过几个不同hash函数计算出key值的bit位，然后将这些bit位设置为1，但这样会产生hash冲突
（3）特点：布隆过滤器判断不存在的key就一定不存在，存在的key可能存在（存在一定的误判，由于hash冲突产生）；没有删除和get方法：都是由于hash冲突导致不能删除某个bit位，因为这个bit位可能被其他数据使用
（4）影响误判率的几个因素：预期容量、hash函数个数、容错率

四：缓存击穿

1：概念：客户端并发访问一个过期的热点数据，导致数据库被并发访问

2：解决方案
（1）：使用分布式锁
（2）：设置热点数据永不过期
（3）：创建定时任务维护热点数据过期时间


五：数据一致性问题

1：什么时候会出现数据一致性问题
在更新数据库数据时会出现数据一致性问题

2：问题情况

（1）：同一个线程先更新数据库，后更新缓存，但是更新缓存时失败了；就会导致数据库中的数据是新数据，缓存中的数据就是旧的，从而产生数据不一致问题
（2）：不同线程：1：线程a更新数据库；2：线程b更新数据库；3：线程b更新缓存；4：线程a更新缓存：因为网络原因，b却比a更早更新了缓存，这就导致了脏数据

3：解决方案：

（1）：先删除缓存，再修改数据库。如果数据库修改失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致，因为读的时候缓存没有，则会去读数据库中的旧数据，然后更新到缓存中。
产生问题：1：线程a删除缓存；2：线程b查询缓存，发现为空；3：线程b查询数据库并加入缓存；4：线程a更新数据库；导致缓存数据不一致

（2）：延时双删：1：线程a删除缓存；2：线程b查询缓存，发现为空；3：线程b查询数据库并加入缓存；4：线程a更新数据库；5：线程a再删除缓存

（3）：串行化：


六：redis持久化

1：redis持久化的两种方式：
RDB和AOF

2：RDB
（1）概念：在指定时间间隔内将内存中的数据写入到磁盘中
（2）触发方式：save、bgsave、自动化
    1：save：该命令会阻塞redis服务器，直到RDB文件写入完成
    2：bgsave：该命令会fork一个子进程去进行RDB文件的写入
    3：自动化：save m n ：在m秒内修改了n个数据触发

3：AOF
（1）概念：将写命令追加到AOF文件中
（2）触发方式：
    1：alaways：一直，只要有修改，就会触发
    2：everySec：每秒修改
    3：no：从不追加
    
4：两者的优缺点


七：redis的删除策略

1：lru（allKeylru和volatilelru：删除最近最少使用的key）
2：noevecation：从不删除
3：random（allKeyRandom和volatileRandom：随机删除key）
4：ttl：删除生存时间最短的key

八：



