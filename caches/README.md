redis相关概念
1：redis在5.x之前都是单线程的；redis6.0之后是多线程的
2：redis是基于内存的

一：redis作为缓存的实现
1：客户端查询数据时先查询缓存中是否存在
2：存在，则返回缓存中数据
3：不存在，则去数据库中查询
4：数据库查询存在该数据，更新缓存，并返回数据
5：数据库中不存在，返回不存在信息

二：缓存雪崩：

1：概念
多个key在同一时间过期，导致客户端查询数据时不经过缓存从而直接查询数据库

2：解决方案
（1）：在过期时间上设置随机值，防止大量key在同一时间过期
（2）：
（3）规避雪崩：redis搭建高可用集群
（4）出现雪崩：服务降级和熔断

三：缓存穿透

1：概念：客户端多次访问一个不存在的key，查询不经过缓存从而直接访问数据库

2：解决方案
（1）：设置null值：对于数据库中也查不到的数据，我们将key值也缓存到redis中，将null作为value值，但是这样只能解决单个key的缓存穿透问题，而且redis中会缓存大量null，浪费空间
（2）：使用布隆过滤器：在查询缓存之前先经过布隆过滤器进行过滤，若数据不存在，则直接返回数据不存在

3：布隆过滤器

（1）概念：布隆过滤器底层依赖于bit，类似于数组，数组存储着bit位，初始每个bit位都为0，当有值时就设置为1
（2）put方法：通过几个不同hash函数计算出key值的bit位，然后将这些bit位设置为1，但这样会产生hash冲突
（3）特点：布隆过滤器判断不存在的key就一定不存在，存在的key可能存在（存在一定的误判，由于hash冲突产生）；没有删除和get方法：都是由于hash冲突导致不能删除某个bit位，因为这个bit位可能被其他数据使用
（4）影响误判率的几个因素：预期容量、hash函数个数、容错率

四：缓存击穿

1：概念：客户端并发访问一个过期的热点数据，导致数据库被并发访问

2：解决方案
（1）：使用分布式锁
（2）：设置热点数据永不过期
（3）：创建定时任务维护热点数据过期时间


五：数据一致性问题

1：什么时候会出现数据一致性问题
在更新数据库数据时会出现数据一致性问题

2：问题情况

（1）：同一个线程先更新数据库，后更新缓存，但是更新缓存时失败了；就会导致数据库中的数据是新数据，缓存中的数据就是旧的，从而产生数据不一致问题
（2）：不同线程：1：线程a更新数据库；2：线程b更新数据库；3：线程b更新缓存；4：线程a更新缓存：因为网络原因，b却比a更早更新了缓存，这就导致了脏数据

3：解决方案：

（1）：先删除缓存，再修改数据库。如果数据库修改失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致，因为读的时候缓存没有，则会去读数据库中的旧数据，然后更新到缓存中。
产生问题：1：线程a删除缓存；2：线程b查询缓存，发现为空；3：线程b查询数据库并加入缓存；4：线程a更新数据库；导致缓存数据不一致

（2）：延时双删：1：线程a删除缓存；2：线程b查询缓存，发现为空；3：线程b查询数据库并加入缓存；4：线程a更新数据库；5：线程a再删除缓存

（3）：串行化：


六：redis持久化

1：redis持久化过程
（1）：redis开机的时候会加载持久化文件（第一次开机的时候没有）
（2）：redis启动后，我们在往redis中写入数据的时候，他会在某一时刻将内存中的数据写入到磁盘中

2：redis持久化的两种方式：
RDB和AOF：RDB持久化默认

3：RDB
（1）概念：在指定时间间隔内将内存中的数据写入到磁盘中（单独fork一个子进程来进行持久化，先将数据写入到一个临时文件，持久化结束之后将原来的持久化文件替换掉；以二进制方式写入磁盘）
（2）触发方式：save、bgsave、自动化（在没有开启AOF然后shutdown的时候）
    1：save：该命令会阻塞redis服务器，直到RDB文件写入完成
    2：bgsave：该命令会fork一个子进程去进行RDB文件的写入；异步进行快照操作
    3：自动化：save m n ：在m秒内修改了n个数据触发
    4：flushall
（3）存储位置：dump.rdb

4：AOF
（1）概念：将写命令追加到AOF文件中
（2）触发方式：
    1：alaways：一直，只要有修改，就会触发
    2：everySec：每秒修改
    3：no：从不追加
（3）工作流程：
    1：将所有写命令追加到aof_buf缓冲区
    2：aof缓冲区根据对应的策略向硬盘做同步操作
    3：随着aof文件越来越大，需要定期对aof进行重写
    4：当redis重启之后就可以加载aof文件进行数据恢复了
    
5：两者的优缺点

优点
rdb：会fork子进程，启动redis的时候，从磁盘加载持久化数据非常快（rdb适合大规模的数据恢复，对数据完整性和一致性不高，在一定时间内做一次备份，如果redis挂了的话，就会丢失最后一次快照后的所有操作）
aof：不会fork子进程，但aof重写会fork子进程，丢失数据不会超过一秒

缺点：
rdb：有可能会丢失最后一次之后写入的数据；需要fork子进程进行持久化
aof：启动redis时，加载持久化数据不如rdb快。

6：建议
两种持久化机制同时开启，如果两个同时开启，优先使用aof持久化机制。


七：redis的删除策略

1：定时删除：在指定时间删除
2：惰性删除：到了过期时间先不删除，直到下一次使用的时候进行删除
3：定期删除：
（1）：redis在启动的时候读取配置文件hz的值，默认为10
（2）：每秒执行hz次serverCron()->dataBasesCron()->activeExpireCyle()
（3）：

redis使用的定期删除+惰性删除

逐出算法：



1：lru（allKeylru和volatilelru：删除最近最少使用的key）
2：noevecation：从不删除
3：random（allKeyRandom和volatileRandom：随机删除key）
4：ttl：删除生存时间最短的key

八：位图

1：什么是位图

2：位图的应用场景
（1）实现微信朋友圈点赞功能：点赞、取消点赞、查看是否点赞、统计一共多少点赞；但使用位图不能实现有谁点赞功能


九：redis中的一些面试题

1：如何查看当前键是否存在
exists key

2：redis为什么这么快？单线程
（1）：redis使用了单线程架构和I/O多路复用模型
（2）：纯内存访问
（3）：由于单线程避免了线程上下文切换带来的资源消耗

3：为什么aof要先把命令追加到缓冲区
redis使用单线程响应命令，如果每次写入命令都直接追加到硬盘，性能就会取决于硬盘负载。







